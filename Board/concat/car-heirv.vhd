-- VHDL Entity Board.ebs3_mc.symbol
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 07:34:25 07.03.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY ebs3_mc IS
    GENERIC( 
        c_btnsNb           : positive := 2;
        c_clockFrequencyHz : positive := 50000000;
        c_dataWidth        : positive := 32;
        c_programFile      : string   := "C:/dev/car-heirv/Simulation/code_mc_ebs3_bram.txt"
    );
    PORT( 
        btns      : IN     std_ulogic_vector (c_btnsNb-1 DOWNTO 0);
        clk       : IN     std_uLogic;
        en_full_n : IN     std_ulogic;
        en_step_n : IN     std_ulogic;
        rst_n     : IN     std_uLogic;
        LED_G     : OUT    std_uLogic;
        LED_R     : OUT    std_uLogic;
        dbg_leds  : OUT    std_ulogic_vector (31 DOWNTO 0);
        heartbeat : OUT    std_uLogic;
        leds      : OUT    std_ulogic_vector (c_dataWidth-1 DOWNTO 0);
        sys_en    : OUT    std_ulogic
    );

-- Declarations

END ebs3_mc ;





LIBRARY ieee;
USE ieee.std_logic_1164.all;

PACKAGE gates IS

--  constant gateDelay: time := 1 ns;
  constant gateDelay: time := 0.1 ns;

END gates;




-- VHDL Entity sequential.freqDivider.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:46:18 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY freqDivider IS
    GENERIC( 
        divideValue : positive := 256;
        delay       : time     := gateDelay
    );
    PORT( 
        clock  : IN     std_ulogic;
        reset  : IN     std_ulogic;
        enable : OUT    std_ulogic
    );

-- Declarations

END freqDivider ;





--------------------------------------------------------------------------------
-- Copyright 2012 HES-SO Valais Wallis (www.hevs.ch)
--------------------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3 of the License, or
-- (at your option) any later version.
--
-- This program IS distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
-- You should have received a copy of the GNU General Public License along with
-- this program. If not, see <http://www.gnu.org/licenses/>
-- -----------------------------------------------------------------------------
-- Common Lib
--
-- -----------------------------------------------------------------------------
--  Authors:
--    cof: [François Corthay](francois.corthay@hevs.ch)
--    guo: [Oliver A. Gubler](oliver.gubler@hevs.ch)
-- -----------------------------------------------------------------------------
-- Changelog:
--   2016-06 : guo
--     added function sel
--   2015-06 : guo
--     added counterBitNb
--     added documentation
-- -----------------------------------------------------------------------------
library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;

PACKAGE CommonLib IS

  ------------------------------------------------------------------------------
  -- Returns the number of bits needed to represent the given val
  -- Examples:
  --   requiredBitNb(1) = 1   (1)
  --   requiredBitNb(2) = 2   (10)
  --   requiredBitNb(3) = 2   (11)
  function requiredBitNb(val : integer) return integer;

  ------------------------------------------------------------------------------
  -- Returns the number of bits needed to count val times (0 to val-1)
  -- Examples:
  --   counterBitNb(1) = 1    (0)
  --   counterBitNb(2) = 1    (0->1)
  --   counterBitNb(3) = 2    (0->1->10)
  function counterBitNb(val : integer) return integer;

  ------------------------------------------------------------------------------
  -- Functions to return one or the other input based on a boolean.
  -- Can be used to build conditional constants.
  -- Example:
  --   constant bonjour_c : string := sel(ptpRole = master, "fpga20", "fpga02");
  function sel(Cond : BOOLEAN; If_True, If_False : integer)
                                            return integer;
  function sel(Cond : BOOLEAN; If_True, If_False : string)
                                            return string;
  function sel(Cond : BOOLEAN; If_True, If_False : std_ulogic_vector)
                                            return std_ulogic_vector;
  function sel(Cond : BOOLEAN; If_True, If_False : unsigned)
                                            return unsigned;
  function sel(Cond : BOOLEAN; If_True, If_False : signed)
                                            return signed;

END CommonLib;




--------------------------------------------------------------------------------
-- Copyright 2012 HES-SO Valais Wallis (www.hevs.ch)
--------------------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3 of the License, or
-- (at your option) any later version.
--
-- This program IS distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
-- You should have received a copy of the GNU General Public License along with
-- this program. If not, see <http://www.gnu.org/licenses/>
-- -----------------------------------------------------------------------------
-- Often used functions
--
-- -----------------------------------------------------------------------------
--  Authors:
--    cof: [François Corthay](francois.corthay@hevs.ch)
--    guo: [Oliver A. Gubler](oliver.gubler@hevs.ch)
-- -----------------------------------------------------------------------------
-- Changelog:
--   2016-06 : guo
--     added function sel
--   2015-06 : guo
--     added counterBitNb
-- -----------------------------------------------------------------------------
PACKAGE BODY CommonLib IS

  function requiredBitNb (val : integer) return integer is
    variable powerOfTwo, bitNb : integer;
  begin
    powerOfTwo := 1;
    bitNb := 0;
    while powerOfTwo <= val loop
      powerOfTwo := 2 * powerOfTwo;
      bitNb := bitNb + 1;
    end loop;
    return bitNb;
  end requiredBitNb;

  function counterBitNb (val : integer) return integer is
    variable powerOfTwo, bitNb : integer;
  begin
    powerOfTwo := 1;
    bitNb := 0;
    while powerOfTwo < val loop
      powerOfTwo := 2 * powerOfTwo;
      bitNb := bitNb + 1;
    end loop;
    return bitNb;
  end counterBitNb;

  function sel(Cond : BOOLEAN; If_True, If_False : integer)
                                            return integer is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : string)
                                            return string is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : std_ulogic_vector)
                                            return std_ulogic_vector is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : unsigned)
                                            return unsigned is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : signed)
                                            return signed is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

END CommonLib;




-- LIBRARY Common;
  use work.CommonLib.all;

ARCHITECTURE RTL OF freqDivider IS

  signal count: unsigned(requiredBitNb(divideValue)-1 downto 0);

BEGIN

  countEndlessly: process(reset, clock)
  begin
    if reset = '1' then
      count <= (others => '0');
    elsif rising_edge(clock) then
      if count = 0 then
        count <= to_unsigned(divideValue-1, count'length);
      else
        count <= count-1 ;
      end if;
    end if;
  end process countEndlessly;

  enable <= '1' after delay when count = 0
    else '0' after delay;

END ARCHITECTURE RTL;




-- VHDL Entity sequential.TFF.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:46:18 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY TFF IS
    GENERIC( 
        delay : time := gateDelay
    );
    PORT( 
        CLK : IN     std_uLogic;
        CLR : IN     std_uLogic;
        T   : IN     std_uLogic;
        Q   : OUT    std_uLogic
    );

-- Declarations

END TFF ;





ARCHITECTURE sim OF TFF IS

  signal q_int: std_ulogic;

BEGIN

  process(clk, clr)
  begin
    if clr = '1' then
      q_int <= '0' after delay;
    elsif rising_edge(clk) then
      q_int <= t xor q_int after delay;
    end if;
  end process;

  q <= q_int;

END sim;




-- VHDL Entity gates.bufferUlogic.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:34:48 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY bufferUlogic IS
    GENERIC( 
        delay : time := gateDelay
    );
    PORT( 
        in1  : IN     std_uLogic;
        out1 : OUT    std_uLogic
    );

-- Declarations

END bufferUlogic ;





ARCHITECTURE sim OF bufferUlogic IS
BEGIN
  out1 <= in1 after delay;
END ARCHITECTURE sim;




-- VHDL Entity gates.inverter.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:35:14 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY inverter IS
    GENERIC( 
        delay : time := gateDelay
    );
    PORT( 
        in1  : IN     std_uLogic;
        out1 : OUT    std_uLogic
    );

-- Declarations

END inverter ;





ARCHITECTURE sim OF inverter IS
BEGIN
  out1 <= NOT in1 after delay;
END sim;




-- VHDL Entity gates.or2.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:35:09 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY or2 IS
    GENERIC( 
        delay : time := gateDelay
    );
    PORT( 
        in1  : IN     std_uLogic;
        in2  : IN     std_uLogic;
        out1 : OUT    std_uLogic
    );

-- Declarations

END or2 ;





ARCHITECTURE sim OF or2 IS
BEGIN
  out1 <= in1 or in2 after delay;
END ARCHITECTURE sim;




-- VHDL Entity common.debouncer.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:43:38 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.NUMERIC_STD.all;

ENTITY debouncer IS
    GENERIC( 
        counterBitNb : positive   := 18;
        invertInput  : std_ulogic := '0'
    );
    PORT( 
        clock     : IN     std_ulogic;
        input     : IN     std_ulogic;
        reset     : IN     std_ulogic;
        debounced : OUT    std_ulogic
    );

-- Declarations

END debouncer ;





-- filename:          debouncer.vhd
-- kind:              vhdl file
-- first created:     05.03.2012
-- created by:        zas
--------------------------------------------------------------------------------
-- History:
-- v0.1 : zas 05.03.2012 -- Initial Version
-- v0.2 : cof 22.01.2013 -- synchronization to clock
--                       -- direct reaction on both edges
--------------------------------------------------------------------------------
-- Description: 
-- Debounces a button on both edges.
--             _   _   ____________________   _   _
-- input  ____/ \_/ \_/                    \_/ \_/ \______
--              _____________________________
-- output _____/                             \____________
--
--------------------------------------------------------------------------------

ARCHITECTURE rtl OF debouncer IS
 
  signal debounceCounter : unsigned(counterBitNb-1 downto 0);
  signal inputSynch, inputDelayed, inputChanged : std_ulogic;
 
BEGIN
  ------------------------------------------------------------------------------
                                                   -- Synchronize input to clock
  synchInput: process(reset, clock)
  begin
    if reset = '1' then
      inputSynch <= '0';
    elsif rising_edge(clock) then
      inputSynch <= input xor invertInput;
    end if;
  end process synchInput;

  ------------------------------------------------------------------------------
                                                           -- Find edge on input
  delayInput: process(reset, clock)
  begin
    if reset = '1' then
      inputDelayed <= '0';
    elsif rising_edge(clock) then
      inputDelayed <= inputSynch;
    end if;
  end process delayInput;

  inputChanged <= '1' when inputDelayed /= inputSynch
    else '0';

  ------------------------------------------------------------------------------
                                                             -- Debounce counter
  countDeadTime: process(reset, clock)
  begin
    if reset = '1' then
      debounceCounter <= (others => '0');
    elsif rising_edge(clock) then
      if debounceCounter = 0 then
        if inputChanged = '1' then
          debounceCounter <= debounceCounter - 1;
        end if;
      else
        debounceCounter <= debounceCounter - 1;
      end if;
    end if;
  end process countDeadTime;

  ------------------------------------------------------------------------------
                                                                -- Update output
  updateOutput: process(reset, clock)
  begin
    if reset = '1' then
      debounced <= '0';
    elsif rising_edge(clock) then
      if (inputChanged = '1') and (debounceCounter = 0) then
        debounced <= input;
      elsif debounceCounter = 1 then
        debounced <= input;
      end if;
    end if;
  end process updateOutput;
 
END ARCHITECTURE rtl;




-- VHDL Entity common.edgeDetector.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 17:10:33 10/02/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;

ENTITY edgeDetector IS
    PORT( 
        clock   : IN     std_ulogic;
        pulse   : IN     std_ulogic;
        reset   : IN     std_ulogic;
        falling : OUT    std_ulogic;
        rising  : OUT    std_ulogic
    );

-- Declarations

END edgeDetector ;





--------------------------------------------------------------------------------
-- Copyright 2014 HES-SO Valais Wallis (www.hevs.ch)
--
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3 of the License, or
-- (at your option) any later version.
--
-- This program IS distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
-- You should have received a copy of the GNU General Public License along with
-- this program. If not, see <http://www.gnu.org/licenses/>
--------------------------------------------------------------------------------
-- EdgeDetector
--   Detect rising and falling edges of a signal.
--
--------------------------------------------------------------------------------
-- History:
-- v0.1 : guo 2014-04-02 -- Initial version
-- v1.0 : cof 2019-10-02 -- Updated symbol
--------------------------------------------------------------------------------
ARCHITECTURE RTL OF edgeDetector IS
  
  SIGNAL pulse_delayed : std_ulogic;
  SIGNAL rising_detected_s : std_ulogic;
  SIGNAL falling_detected_s : std_ulogic;

BEGIN

  -- delay pulse
  reg : PROCESS (reset, clock)
  BEGIN
    IF reset = '1' THEN
      pulse_delayed <= '0';
    ELSIF rising_edge(clock) THEN
      pulse_delayed <= pulse;  
    END IF;    
  END PROCESS reg ;
  
  -- edge detection
  rising <= '1' when (pulse = '1') and (pulse_delayed = '0')
    else '0'; 
  falling <= '1' when (pulse = '0') and (pulse_delayed = '1')
    else '0'; 
  
END ARCHITECTURE RTL;




-- VHDL Entity HEIRV32_MC.heirv32_mc.symbol
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 14:49:46 09.05.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY heirv32_mc IS
    GENERIC( 
        g_programFile : string   := "C:/dev/car-heirv/Simulation/code.txt";
        g_btnsNb      : positive := 2;
        g_dataWidth   : positive := 32
    );
    PORT( 
        btns     : IN     std_ulogic_vector (g_btnsNb-1 DOWNTO 0);
        clk      : IN     std_ulogic;
        en       : IN     std_ulogic;
        rst      : IN     std_ulogic;
        dbg_leds : OUT    std_ulogic_vector (31 DOWNTO 0);
        leds     : OUT    std_ulogic_vector (g_dataWidth-1 DOWNTO 0);
        test     : OUT    std_ulogic_vector (32+3+2+2+1+1+1+2+1+1+2 - 1 DOWNTO 0)
    );

-- Declarations

END heirv32_mc ;





-- VHDL Entity HEIRV32.ALU.symbol
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 11:16:47 04.11.2022
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
use work.gates.all;

ENTITY ALU IS
    GENERIC( 
        g_datawidth : positive := 32;
        g_tALU      : time     := 120 ps
    );
    PORT( 
        ctrl : IN     std_ulogic_vector (2 DOWNTO 0);
        srcA : IN     std_ulogic_vector (g_dataWidth-1 DOWNTO 0);
        srcB : IN     std_ulogic_vector (g_dataWidth-1 DOWNTO 0);
        res  : OUT    std_ulogic_vector (g_dataWidth-1 DOWNTO 0);
        zero : OUT    std_ulogic
    );

-- Declarations

END ALU ;





 ARcHiTectURe lLLLLl OF ALU iS sIgNaL L : sTd_UlOgic_VecTor(REs'RaNGe); sIgNal LL 
: Std_uLogiC; BEgin LL <= '1' wHEn l = (L'RAngE => '0') elsE '0'; zErO <= Ll AFTER 
G_tAlU; RES <= l AftEr G_Talu; llL : PRocEss(srcA, SrcB, cTrl) BeGIN CAse cTrL IS 
WHEn "000" => L <= StD_ULOgiC_VeCtOR(rESize( UnSIGNED(srcA) + UNSIgNED(sRCB), l'LeNgth 
)); when "001" => L <= StD_uLOGic_VEctOr(rEsiZE( uNsigNed(SrCa) - UnSIGNed(SrcB), 
l'LenGTh )); WheN "010" => l <= sRCa and SrCB; whEn "011" => L <= srCA or sRcB; WHEn 
"101" => if SRca < SRCB ThEN L <= (L'HiGh dowNto 1 => '0') & '1'; else L <= (L'HiGh 
dowNTO 1 => '0') & '0'; END iF; WHEn OtheRS => l <= (OTHers => '-'); eND case; END 
process LLL; enD architectUre LLlLll;



-- VHDL Entity HEIRV32.bufferStdULogEnable.symbol
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 15:01:42 11.10.2022
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
use work.gates.all;

ENTITY bufferStdULogEnable IS
    GENERIC( 
        g_dataWidth : positive := 32
    );
    PORT( 
        clk  : IN     std_ulogic;
        en   : IN     std_uLogic;
        in1  : IN     std_ulogic_vector (g_dataWidth-1 DOWNTO 0);
        rst  : IN     std_ulogic;
        out1 : OUT    std_ulogic_vector (g_dataWidth - 1 DOWNTO 0)
    );

-- Declarations

END bufferStdULogEnable ;






ARCHITECTURE rtl OF bufferStdULogEnable IS
BEGIN

    buffering:process(rst, CLK)
	begin
		if rst = '1' then
			out1 <= (others=>'0');
		elsif rising_edge(CLK) then
			if EN = '1' then
				out1 <= in1;
			end if;
		end if;
	end process buffering;
	
END ARCHITECTURE rtl;





-- VHDL Entity gates.and2.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:34:52 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY and2 IS
    GENERIC( 
        delay : time := gateDelay
    );
    PORT( 
        in1  : IN     std_uLogic;
        in2  : IN     std_uLogic;
        out1 : OUT    std_uLogic
    );

-- Declarations

END and2 ;





ARCHITECTURE sim OF and2 IS
BEGIN
  out1 <= in1 and in2 after delay;
END ARCHITECTURE sim;




-- VHDL Entity HEIRV32_MC.controlUnit.symbol
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 11:25:37 03.11.2022
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
use work.gates.all;

ENTITY controlUnit IS
    GENERIC( 
        g_datawidth : positive := 32
    );
    PORT( 
        clk        : IN     std_ulogic;
        en         : IN     std_ulogic;
        funct3     : IN     std_ulogic_vector (2 DOWNTO 0);
        funct7     : IN     std_ulogic;
        op         : IN     std_ulogic_vector (6 DOWNTO 0);
        rst        : IN     std_ulogic;
        zero       : IN     std_ulogic;
        ALUControl : OUT    std_ulogic_vector (2 DOWNTO 0);
        ALUSrcA    : OUT    std_ulogic_vector (1 DOWNTO 0);
        ALUSrcB    : OUT    std_ulogic_vector (1 DOWNTO 0);
        IRWrite    : OUT    std_ulogic;
        PCWrite    : OUT    std_ulogic;
        adrSrc     : OUT    std_uLogic;
        immSrc     : OUT    std_ulogic_vector (1 DOWNTO 0);
        memWrite   : OUT    std_ulogic;
        regwrite   : OUT    std_ulogic;
        resultSrc  : OUT    std_ulogic_vector (1 DOWNTO 0)
    );

-- Declarations

END controlUnit ;





-- VHDL Entity HEIRV32.aluDecoder.symbol
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 11:24:21 04.11.2022
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
use work.gates.all;

ENTITY aluDecoder IS
    GENERIC( 
        g_tDec : time := 25 ps
    );
    PORT( 
        ALUOp      : IN     std_ulogic_vector (1 DOWNTO 0);
        funct3     : IN     std_ulogic_vector (2 DOWNTO 0);
        funct7     : IN     std_ulogic;
        op         : IN     std_ulogic;
        ALUControl : OUT    std_ulogic_vector (2 DOWNTO 0)
    );

-- Declarations

END aluDecoder ;





-- Setup ALU operation based on instruction
ARCHITECTURE rtl OF aluDecoder IS
    signal lsig_rTypeSub : std_ulogic;
BEGIN
    lsig_rTypeSub <= funct7 and op; -- true for R-type substract

    decode : process(op, funct3, funct7, ALUOp, lsig_rTypeSub)
    begin
        case ALUOp is
            when "00" => ALUControl <= "000" after g_tDec; -- addition
            when "01" => ALUControl <= "001" after g_tDec; -- substraction
            when others =>
                case funct3 is -- R-type or I-type
                    when "000" =>
                        if lsig_rTypeSub = '1' then
                            ALUControl <= "001" after g_tDec; -- sub
                        else
                            ALUControl <= "000" after g_tDec; -- add, addi
                        end if;
                    when "010" => ALUControl <= "101" after g_tDec; -- slt, slti
                    when "110" => ALUControl <= "011" after g_tDec; -- or, ori
                    when "111" => ALUControl <= "010" after g_tDec; -- and, andi
                    when others => ALUControl <= "---" after g_tDec; -- unknown
                end case;
        end case;
    end process decode;
END ARCHITECTURE rtl;




-- VHDL Entity HEIRV32_MC.instrDecoder.symbol
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 15:47:22 04.10.2022
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
use work.gates.all;

ENTITY instrDecoder IS
    PORT( 
        op     : IN     std_ulogic_vector (6 DOWNTO 0);
        immSrc : OUT    std_ulogic_vector (1 DOWNTO 0)
    );

-- Declarations

END instrDecoder ;





-- Defines extend type based on instruction
ARCHITECTURE rtl OF instrDecoder IS
BEGIN

    decode : process(op)
    begin
        case op is
            when "0000011" => immSrc <= "00"; -- lw
            when "0100011" => immSrc <= "01"; -- sw
            when "0110011" => immSrc <= "--"; -- R-type
            when "1100011" => immSrc <= "10"; -- beq
            when "0010011" => immSrc <= "00"; -- l-type ALU
            when "1101111" => immSrc <= "11"; -- jal
            when others => immSrc <= "--"; -- unknwon
        end case;
    end process decode;

END ARCHITECTURE rtl;




-- VHDL Entity HEIRV32_MC.mainFSM.symbol
--
-- Created:
--          by - axel.amand.UNKNOWN (WE2332101)
--          at - 09:29:07 18.10.2022
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
use work.gates.all;

ENTITY mainFSM IS
    PORT( 
        clk       : IN     std_ulogic;
        en        : IN     std_ulogic;
        op        : IN     std_ulogic_vector (6 DOWNTO 0);
        rst       : IN     std_ulogic;
        ALUOp     : OUT    std_ulogic_vector (1 DOWNTO 0);
        ALUSrcA   : OUT    std_ulogic_vector (1 DOWNTO 0);
        ALUSrcB   : OUT    std_ulogic_vector (1 DOWNTO 0);
        IRWrite   : OUT    std_ulogic;
        PCupdate  : OUT    std_uLogic;
        adrSrc    : OUT    std_uLogic;
        branch    : OUT    std_uLogic;
        memWrite  : OUT    std_ulogic;
        regwrite  : OUT    std_ulogic;
        resultSrc : OUT    std_ulogic_vector (1 DOWNTO 0)
    );

-- Declarations

END mainFSM ;





--
-- VHDL Architecture HEIRV32_MC.mainFSM.fsm
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 07:35:56 07.03.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
use work.gates.all;
 
ARCHITECTURE fsm OF mainFSM IS

    TYPE STATE_TYPE IS (
        s0_Fetch,
        s1_Decode,
        s2_MemAdr,
        s6_ExecuteR,
        s8_ExecuteI,
        s9_JAL,
        s10_BEQ,
        s3_MemRead,
        s4_MemWB,
        s5_MemWrite,
        s7_ALUWB
    );
 
    -- Declare current and next state signals
    SIGNAL current_state : STATE_TYPE;
    SIGNAL next_state : STATE_TYPE;

BEGIN

    -----------------------------------------------------------------
    clocked_proc : PROCESS ( 
        clk,
        rst
    )
    -----------------------------------------------------------------
    BEGIN
        IF (rst = '1') THEN
            current_state <= s0_Fetch;
        ELSIF (clk'EVENT AND clk = '1') THEN
            current_state <= next_state;
        END IF;
    END PROCESS clocked_proc;
 
    -----------------------------------------------------------------
    nextstate_proc : PROCESS ( 
        current_state,
        en,
        op
    )
    -----------------------------------------------------------------
    BEGIN
        CASE current_state IS
            WHEN s0_Fetch => 
                IF (en = '1') THEN 
                    next_state <= s1_Decode;
                ELSE
                    next_state <= s0_Fetch;
                END IF;
            WHEN s1_Decode => 
                IF ((op = "0000011" OR op = "0100011") AND en = '1') THEN 
                    next_state <= s2_MemAdr;
                ELSIF (op = "0110011" AND en = '1') THEN 
                    next_state <= s6_ExecuteR;
                ELSIF (op = "0010011" AND en = '1') THEN 
                    next_state <= s8_ExecuteI;
                ELSIF (op = "1101111" AND en = '1') THEN 
                    next_state <= s9_JAL;
                ELSIF (op = "1100011" AND en = '1') THEN 
                    next_state <= s10_BEQ;
                ELSIF (en = '1') THEN 
                    next_state <= s0_Fetch;
                ELSE
                    next_state <= s1_Decode;
                END IF;
            WHEN s2_MemAdr => 
                IF (op = "0000011" AND en = '1') THEN 
                    next_state <= s3_MemRead;
                ELSIF (op = "0100011" AND en = '1') THEN 
                    next_state <= s5_MemWrite;
                ELSIF (en = '1') THEN 
                    next_state <= s0_Fetch;
                ELSE
                    next_state <= s2_MemAdr;
                END IF;
            WHEN s6_ExecuteR => 
                IF (en = '1') THEN 
                    next_state <= s7_ALUWB;
                ELSE
                    next_state <= s6_ExecuteR;
                END IF;
            WHEN s8_ExecuteI => 
                IF (en = '1') THEN 
                    next_state <= s7_ALUWB;
                ELSE
                    next_state <= s8_ExecuteI;
                END IF;
            WHEN s9_JAL => 
                IF (en = '1') THEN 
                    next_state <= s7_ALUWB;
                ELSE
                    next_state <= s9_JAL;
                END IF;
            WHEN s10_BEQ => 
                IF (en = '1') THEN 
                    next_state <= s0_Fetch;
                ELSE
                    next_state <= s10_BEQ;
                END IF;
            WHEN s3_MemRead => 
                IF (en = '1') THEN 
                    next_state <= s4_MemWB;
                ELSE
                    next_state <= s3_MemRead;
                END IF;
            WHEN s4_MemWB => 
                IF (en = '1') THEN 
                    next_state <= s0_Fetch;
                ELSE
                    next_state <= s4_MemWB;
                END IF;
            WHEN s5_MemWrite => 
                IF (en = '1') THEN 
                    next_state <= s0_Fetch;
                ELSE
                    next_state <= s5_MemWrite;
                END IF;
            WHEN s7_ALUWB => 
                IF (en = '1') THEN 
                    next_state <= s0_Fetch;
                ELSE
                    next_state <= s7_ALUWB;
                END IF;
            WHEN OTHERS =>
                next_state <= s0_Fetch;
        END CASE;
    END PROCESS nextstate_proc;
 
    -----------------------------------------------------------------
    output_proc : PROCESS ( 
        current_state
    )
    -----------------------------------------------------------------
    BEGIN
        -- Default Assignment
        ALUOp <= "00";
        ALUSrcA <= "00";
        ALUSrcB <= "00";
        IRWrite <= '0';
        PCupdate <= '0';
        adrSrc <= '0';
        branch <= '0';
        memWrite <= '0';
        regwrite <= '0';
        resultSrc <= "00";

        -- Combined Actions
        CASE current_state IS
            WHEN s0_Fetch => 
                adrSrc <= '0' ;
                IRWrite <= '1' ;
                ALUSrcA <= "00" ;
                ALUSrcB <= "10" ;
                ALUOp <= "00" ;
                resultSrc <= "10" ;
                PCupdate <= '1' ;
            WHEN s1_Decode => 
                ALUSrcA <= "01" ;
                ALUSrcB <= "01" ;
                ALUOp <= "00" ;
            WHEN s2_MemAdr => 
                ALUSrcA <= "10" ;
                ALUSrcB <= "01" ;
                ALUOp <= "00" ;
            WHEN s6_ExecuteR => 
                ALUSrcA <= "10" ;
                ALUSrcB <= "00" ;
                ALUOp <= "10" ;
            WHEN s8_ExecuteI => 
                ALUSrcA <= "10" ;
                ALUSrcB <= "01" ;
                ALUOp <= "10" ;
            WHEN s9_JAL => 
                ALUSrcA <= "01" ;
                ALUSrcB <= "10" ;
                ALUOp <= "00" ;
                resultSrc <= "00" ;
                PCupdate <= '1' ;
            WHEN s10_BEQ => 
                ALUSrcA <= "10" ;
                ALUSrcB <= "00" ;
                ALUOp <= "01" ;
                resultSrc <= "00" ;
                branch <= '1' ;
            WHEN s3_MemRead => 
                adrSrc <= '1' ;
                resultSrc <= "00" ;
            WHEN s4_MemWB => 
                resultSrc <= "01" ;
                regwrite <= '1' ;
            WHEN s5_MemWrite => 
                adrSrc <= '1' ;
                resultSrc <= "00" ;
                memWrite <= '1' ;
            WHEN s7_ALUWB => 
                resultSrc <= "00" ;
                regwrite <= '1' ;
            WHEN OTHERS =>
                NULL;
        END CASE;
    END PROCESS output_proc;
 
END fsm;




--
-- VHDL Architecture HEIRV32_MC.controlUnit.masterVersion
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 07:35:46 07.03.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
use work.gates.all;

-- LIBRARY HEIRV32;
-- LIBRARY HEIRV32_MC;

ARCHITECTURE masterVersion OF controlUnit IS

    -- Architecture declarations

    -- Internal signal declarations
    SIGNAL ALUOp    : std_ulogic_vector(1 DOWNTO 0);
    SIGNAL PCupdate : std_uLogic;
    SIGNAL branch   : std_uLogic;
    SIGNAL out1     : std_uLogic;


    -- Component Declarations
    COMPONENT and2
    GENERIC (
        delay : time := gateDelay
    );
    PORT (
        in1  : IN     std_uLogic ;
        in2  : IN     std_uLogic ;
        out1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT or2
    GENERIC (
        delay : time := gateDelay
    );
    PORT (
        in1  : IN     std_uLogic ;
        in2  : IN     std_uLogic ;
        out1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT aluDecoder
    GENERIC (
        g_tDec : time := 25 ps
    );
    PORT (
        ALUOp      : IN     std_ulogic_vector (1 DOWNTO 0);
        funct3     : IN     std_ulogic_vector (2 DOWNTO 0);
        funct7     : IN     std_ulogic ;
        op         : IN     std_ulogic ;
        ALUControl : OUT    std_ulogic_vector (2 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT instrDecoder
    PORT (
        op     : IN     std_ulogic_vector (6 DOWNTO 0);
        immSrc : OUT    std_ulogic_vector (1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT mainFSM
    PORT (
        clk       : IN     std_ulogic ;
        en        : IN     std_ulogic ;
        op        : IN     std_ulogic_vector (6 DOWNTO 0);
        rst       : IN     std_ulogic ;
        ALUOp     : OUT    std_ulogic_vector (1 DOWNTO 0);
        ALUSrcA   : OUT    std_ulogic_vector (1 DOWNTO 0);
        ALUSrcB   : OUT    std_ulogic_vector (1 DOWNTO 0);
        IRWrite   : OUT    std_ulogic ;
        PCupdate  : OUT    std_uLogic ;
        adrSrc    : OUT    std_uLogic ;
        branch    : OUT    std_uLogic ;
        memWrite  : OUT    std_ulogic ;
        regwrite  : OUT    std_ulogic ;
        resultSrc : OUT    std_ulogic_vector (1 DOWNTO 0)
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : aluDecoder USE ENTITY HEIRV32.aluDecoder;
--     FOR ALL : and2 USE ENTITY gates.and2;
--     FOR ALL : instrDecoder USE ENTITY HEIRV32_MC.instrDecoder;
--     FOR ALL : mainFSM USE ENTITY HEIRV32_MC.mainFSM;
--     FOR ALL : or2 USE ENTITY gates.or2;
    -- pragma synthesis_on


BEGIN

    -- Instance port mappings.
    U_1 : and2
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => zero,
            in2  => branch,
            out1 => out1
        );
    U_0 : or2
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => out1,
            in2  => PCupdate,
            out1 => PCWrite
        );
    U_aluDecoder : aluDecoder
        GENERIC MAP (
            g_tDec => 25 ps
        )
        PORT MAP (
            ALUOp      => ALUOp,
            funct3     => funct3,
            funct7     => funct7,
            op         => op(5),
            ALUControl => ALUControl
        );
    U_instrDecoder : instrDecoder
        PORT MAP (
            op     => op,
            immSrc => immSrc
        );
    U_mainFSM : mainFSM
        PORT MAP (
            clk       => clk,
            en        => en,
            op        => op,
            rst       => rst,
            ALUOp     => ALUOp,
            ALUSrcA   => ALUSrcA,
            ALUSrcB   => ALUSrcB,
            IRWrite   => IRWrite,
            PCupdate  => PCupdate,
            adrSrc    => adrSrc,
            branch    => branch,
            memWrite  => memWrite,
            regwrite  => regwrite,
            resultSrc => resultSrc
        );

END masterVersion;




-- VHDL Entity HEIRV32.extend.symbol
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 11:09:36 04.11.2022
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
use work.gates.all;

ENTITY extend IS
    GENERIC( 
        g_dataWidth : positive := 32;
        g_tExt      : time     := 35 ps
    );
    PORT( 
        input    : IN     std_ulogic_vector (31 DOWNTO 7);
        src      : IN     std_ulogic_vector (1 DOWNTO 0);
        extended : OUT    std_ulogic_vector (g_dataWidth-1 DOWNTO 0)
    );

-- Declarations

END extend ;





ARCHITECtURe llLlL of eXTEnD iS SignAl lL : STd_ULOgIC_vECToR(1 DOwNTO 0); Signal 
LLll: Std_uLoGiC_vECTor(ExTeNDEd'range); BegIn ExTeNDEd<=llll;
 Lll : pROceSs(InPUt, lL) BEgIN CaSE lL iS when "00" => Llll <= (12 to 31 => InPuT(
31)) & inPUT(31 DoWNTo 20) AFtEr g_tEXt; WHEn "01" => lllL <= (12 To 31 => iNput(
31)) & INpUT(31 dOwnTO 25) & iNPUT(11 dOWNto 7) AFTer G_TexT; WhEn "10" => LLLL <= 
(12 TO 31 => INPuT(31)) & inPUt(7) & inpUT(30 dowNTo 25) & Input(11 DoWNTo 8) & '0' 
AFTer g_Text; wHEn "11" => LLLl <= (20 to 31 => InPuT(31)) & InPUt(19 dOWntO 12) 
& INPuT(20) & inpuT(30 DownTo 21) & '0' AfTeR g_tExT; WHen Others => llLl <= (oThERS 
=> '-') AFtEr G_TeXT; eND cASE; END PRoCess lll; lL <= SRc; END arChItecture LLLlL;



-- VHDL Entity HEIRV32_MC.instructionDataManager.symbol
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 08:54:11 07.03.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
use work.gates.all;

ENTITY instructionDataManager IS
    GENERIC( 
        g_addrWidth   : positive := 10;
        g_dataWidth   : positive := 32;
        g_programFile : string   := ""
    );
    PORT( 
        adr         : IN     unsigned (g_dataWidth-1 DOWNTO 0);
        clk         : IN     std_ulogic;
        en          : IN     std_ulogic;
        irWrite     : IN     std_ulogic;
        memWrite    : IN     std_ulogic;
        reset       : IN     std_ulogic;
        writeData   : IN     std_ulogic_vector (g_dataWidth-1 DOWNTO 0);
        data        : OUT    std_ulogic_vector (g_dataWidth-1 DOWNTO 0);
        instruction : OUT    std_ulogic_vector (g_dataWidth-1 DOWNTO 0)
    );

-- Declarations

END instructionDataManager ;





-- VHDL Entity HEIRV32_MC.instructionDataMemory.symbol
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 11:20:41 03.03.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
use work.gates.all;

ENTITY instructionDataMemory IS
    GENERIC( 
        g_dataWidth   : positive := 32;
        g_addrWidth   : positive := 10;
        g_programFile : string   := ""
    );
    PORT( 
        address     : IN     unsigned (g_dataWidth-1 DOWNTO 0);
        clk         : IN     std_ulogic;
        en          : IN     std_ulogic;
        reset       : IN     std_ulogic;
        writeData   : IN     std_ulogic_vector (g_dataWidth-1 DOWNTO 0);
        writeEnable : IN     std_ulogic;
        readData    : OUT    std_ulogic_vector (g_dataWidth-1 DOWNTO 0)
    );

-- Declarations

END instructionDataMemory ;





-- VHDL Entity sequential.DFF_pre.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:46:19 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY DFF_pre IS
    GENERIC( 
        delay : time := gateDelay
    );
    PORT( 
        CLK : IN     std_uLogic;
        D   : IN     std_uLogic;
        PRE : IN     std_uLogic;
        Q   : OUT    std_uLogic
    );

-- Declarations

END DFF_pre ;





ARCHITECTURE sim OF DFF_pre IS
BEGIN

  process(clk, pre)
  begin
    if pre = '1' then
      q <= '1' after delay;
    elsif rising_edge(clk) then
      q <= d after delay;
    end if;
  end process;

END sim;




-- VHDL Entity gates.logic0.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:35:14 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY logic0 IS
    PORT( 
        logic_0 : OUT    std_uLogic
    );

-- Declarations

END logic0 ;





ARCHITECTURE sim OF logic0 IS
BEGIN
  logic_0 <= '0';
END sim;




-- VHDL Entity Memory.bramHexAsciiInit.symbol
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 15:51:22 11.10.2022
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
    USE ieee.std_logic_1164.all;
    USE ieee.numeric_std.all;

ENTITY bramHexAsciiInit IS
    GENERIC( 
        addressBitNb : positive := 8;
        dataBitNb    : positive := 8;
        initFile     : string   := "bramInit.txt"
    );
    PORT( 
        clock     : IN     std_ulogic;
        en        : IN     std_ulogic;
        writeEn   : IN     std_ulogic;
        addressIn : IN     std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        dataIn    : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        dataOut   : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0)
    );

-- Declarations

END bramHexAsciiInit ;





library ieee;
  use std.textio.all;
  use ieee.std_logic_textio.all;

ARCHITECTURE rtl OF bramHexASCIIInit IS
    -- Define ramContent type
  type ramContentType is array(0 to (2**addressBitNb)-1) of std_logic_vector(dataBitNb-1 DOWNTO 0);

  -- Define function to create initvalue signal
  impure function ReadRamContentFromFile(ramContentFilenAme : in string) return ramContentType is
    FILE     ramContentFile     : text is in ramContentFilenAme;
    variable ramContentFileLine : line;
    variable ramContent         : ramContentType;
  begin
    for i in ramContentType'range loop
      readline(ramContentFile, ramContentFileLine);
      HREAD(ramContentFileLine, ramContent(i));
    end loop;
    return ramContent;
  end function;

  -- Declare ramContent signal
  shared variable ramContent: ramContentType := ReadRamContentFromFile(initFile);

BEGIN

  -- Port A
  process(clock)
  begin
    if clock'event and clock='1' then
      if en = '1' then
        if writeEn = '1' then
          dataOut <= dataIn;
          ramContent(to_integer(unsigned(addressIn))) := std_logic_vector(dataIn);
        else
          dataOut <= to_stdulogicvector(ramContent(to_integer(unsigned(addressIn))));
        end if;
      end if;
    end if;
  end process;

END ARCHITECTURE rtl;




-- VHDL Entity HEIRV32.bramAddrReducer.symbol
--
-- Created:
--          by - axel.amand.UNKNOWN (WE2332111)
--          at - 16:20:19 11.10.2022
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
use work.gates.all;

ENTITY bramAddrReducer IS
    GENERIC( 
        g_dataWidth : positive := 32;
        g_addrWidth : positive := 10
    );
    PORT( 
        addrIn  : IN     unsigned (g_dataWidth-1 DOWNTO 0);
        addrOut : OUT    std_ulogic_vector (g_addrWidth-1 DOWNTO 0)
    );

-- Declarations

END bramAddrReducer ;





-- Reduces the address to handle 2**10 data/instr
-- Also shifts the address twice, since it goes +4 each clock (and we do not handle half-address access)
ARCHITECTURE rtl OF bramAddrReducer IS
BEGIN
	-- +2 to srr(2) the address (as it makes +4)
	addrOut <= std_ulogic_vector(addrIn(addrOut'high+2 downto addrOut'low+2));
END ARCHITECTURE rtl;




--
-- VHDL Architecture HEIRV32_MC.instructionDataMemory.struct
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 08:27:30 04.04.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
use work.gates.all;

-- LIBRARY HEIRV32;
-- LIBRARY Memory;
-- LIBRARY sequential;

ARCHITECTURE struct OF instructionDataMemory IS

    -- Architecture declarations

    -- Internal signal declarations
    SIGNAL in2     : std_uLogic;
    SIGNAL logic_0 : std_uLogic;
    SIGNAL out1    : std_ulogic_vector(g_addrWidth-1 DOWNTO 0);
    SIGNAL out2    : std_uLogic;


    -- Component Declarations
    COMPONENT logic0
    PORT (
        logic_0 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT or2
    GENERIC (
        delay : time := gateDelay
    );
    PORT (
        in1  : IN     std_uLogic ;
        in2  : IN     std_uLogic ;
        out1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT bramAddrReducer
    GENERIC (
        g_dataWidth : positive := 32;
        g_addrWidth : positive := 10
    );
    PORT (
        addrIn  : IN     unsigned (g_dataWidth-1 DOWNTO 0);
        addrOut : OUT    std_ulogic_vector (g_addrWidth-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT bramHexAsciiInit
    GENERIC (
        addressBitNb : positive := 8;
        dataBitNb    : positive := 8;
        initFile     : string   := "bramInit.txt"
    );
    PORT (
        clock     : IN     std_ulogic ;
        en        : IN     std_ulogic ;
        writeEn   : IN     std_ulogic ;
        addressIn : IN     std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        dataIn    : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        dataOut   : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT DFF_pre
    GENERIC (
        delay : time := gateDelay
    );
    PORT (
        CLK : IN     std_uLogic ;
        D   : IN     std_uLogic ;
        PRE : IN     std_uLogic ;
        Q   : OUT    std_uLogic 
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : DFF_pre USE ENTITY sequential.DFF_pre;
--     FOR ALL : bramAddrReducer USE ENTITY HEIRV32.bramAddrReducer;
--     FOR ALL : bramHexAsciiInit USE ENTITY Memory.bramHexAsciiInit;
--     FOR ALL : logic0 USE ENTITY gates.logic0;
--     FOR ALL : or2 USE ENTITY gates.or2;
    -- pragma synthesis_on


BEGIN

    -- Instance port mappings.
    U_2 : logic0
        PORT MAP (
            logic_0 => logic_0
        );
    U_3 : or2
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => en,
            in2  => in2,
            out1 => out2
        );
    U_bramAddrReducer : bramAddrReducer
        GENERIC MAP (
            g_dataWidth => g_dataWidth,
            g_addrWidth => g_addrWidth
        )
        PORT MAP (
            addrIn  => address,
            addrOut => out1
        );
    U_bram : bramHexAsciiInit
        GENERIC MAP (
            addressBitNb => g_addrWidth,
            dataBitNb    => g_dataWidth,
            initFile     => g_programFile
        )
        PORT MAP (
            clock     => clk,
            en        => out2,
            writeEn   => writeEnable,
            addressIn => out1,
            dataIn    => writeData,
            dataOut   => readData
        );
    U_1 : DFF_pre
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            CLK => clk,
            D   => logic_0,
            PRE => reset,
            Q   => in2
        );

END struct;




-- VHDL Entity HEIRV32_MC.instructionForwarder.symbol
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 17:56:08 06.03.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
use work.gates.all;

ENTITY instructionForwarder IS
    GENERIC( 
        g_dataWidth : positive := 32
    );
    PORT( 
        clk         : IN     std_ulogic;
        en          : IN     std_ulogic;
        irWrite     : IN     std_ulogic;
        readData    : IN     std_ulogic_vector (g_dataWidth-1 DOWNTO 0);
        rst         : IN     std_ulogic;
        instruction : OUT    std_ulogic_vector (g_dataWidth-1 DOWNTO 0)
    );

-- Declarations

END instructionForwarder ;





-- readData must be output on next clock, but the instruction loaded only if irWrite is '1' (FETCH stage)
-- The problem is that the state change of the FSM is also clocked, and will happen the same moment the instruction is loaded
--  => IRWrite will be asserted only a bit after the clock, thus the data would not be forwarded to the instruction line until next clock
--  => desynchronization
-- This block reacts on irWrite to decide wheter to forward the readData or not
ARCHITECTURE rtl OF instructionForwarder IS
    signal lvec_irMem : std_ulogic_vector(readData'range);
    signal lsig_irwrite : std_ulogic;
    attribute BLOCKNET : string;
    attribute BLOCKNET of instruction, readData : signal is "instruction";
BEGIN

--    process(rst, clk)
--    begin
--        if rst = '1' then
--            lvec_irMem <= (others => '0');
--        elsif rising_edge(clk) then
--            if en = '1' and irWrite = '1' then
--                lvec_irMem <= readData;
--            end if;
--        end if;
--    end process;
--    instruction <= lvec_irMem;

    -- Register IRWrite and last data
    regIR : process(rst, clk)
    begin
        if rst = '1' then
            lvec_irMem <= (others => '0');
            --lsig_irwrite <= '0';
        elsif rising_edge(clk) then
            if en = '1' then
                lsig_irwrite <= irWrite;
                -- delay of one clock to ensure fresh data
                if lsig_irwrite = '1' then
                    lvec_irMem <= readData;
                end if;
            end if;
        end if;
    end process regIR;

    -- Based on IRWrite value, either forward actual data or last one
    instruction <= readData when lsig_irwrite = '1' else lvec_irMem;




--    forwardIR : process(readData, irWrite)
--    begin
--        if irWrite = '1' then
--            lvec_irMem <= readData;
--        end if;
--    end process forwardIR;

--    instruction <= lvec_irMem;

END ARCHITECTURE rtl;




--
-- VHDL Architecture HEIRV32_MC.instructionDataManager.struct
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 08:56:33 07.03.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
use work.gates.all;

-- LIBRARY HEIRV32_MC;

ARCHITECTURE struct OF instructionDataManager IS

    -- Architecture declarations

    -- Internal signal declarations

    -- Implicit buffer signal declarations
    SIGNAL data_internal : std_ulogic_vector (g_dataWidth-1 DOWNTO 0);


    -- Component Declarations
    COMPONENT instructionDataMemory
    GENERIC (
        g_dataWidth   : positive := 32;
        g_addrWidth   : positive := 10;
        g_programFile : string   := ""
    );
    PORT (
        address     : IN     unsigned (g_dataWidth-1 DOWNTO 0);
        clk         : IN     std_ulogic ;
        en          : IN     std_ulogic ;
        reset       : IN     std_ulogic ;
        writeData   : IN     std_ulogic_vector (g_dataWidth-1 DOWNTO 0);
        writeEnable : IN     std_ulogic ;
        readData    : OUT    std_ulogic_vector (g_dataWidth-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT instructionForwarder
    GENERIC (
        g_dataWidth : positive := 32
    );
    PORT (
        clk         : IN     std_ulogic ;
        en          : IN     std_ulogic ;
        irWrite     : IN     std_ulogic ;
        readData    : IN     std_ulogic_vector (g_dataWidth-1 DOWNTO 0);
        rst         : IN     std_ulogic ;
        instruction : OUT    std_ulogic_vector (g_dataWidth-1 DOWNTO 0)
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : instructionDataMemory USE ENTITY HEIRV32_MC.instructionDataMemory;
--     FOR ALL : instructionForwarder USE ENTITY HEIRV32_MC.instructionForwarder;
    -- pragma synthesis_on


BEGIN

    -- Instance port mappings.
    U_instrDataMemory : instructionDataMemory
        GENERIC MAP (
            g_dataWidth   => g_dataWidth,
            g_addrWidth   => g_addrWidth,
            g_programFile => g_programFile
        )
        PORT MAP (
            address     => adr,
            clk         => clk,
            en          => en,
            reset       => reset,
            writeData   => writeData,
            writeEnable => memWrite,
            readData    => data_internal
        );
    U_instrForward : instructionForwarder
        GENERIC MAP (
            g_dataWidth => g_dataWidth
        )
        PORT MAP (
            clk         => clk,
            en          => en,
            irWrite     => irWrite,
            readData    => data_internal,
            rst         => reset,
            instruction => instruction
        );

    -- Implicit buffered output assignments
    data <= data_internal;

END struct;




-- VHDL Entity HEIRV32.bufferUnsignedEnable.symbol
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 11:09:50 04.11.2022
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY bufferUnsignedEnable IS
    GENERIC( 
        g_bitNb : positive := 32;
        g_tPC   : time     := 40 ps
    );
    PORT( 
        clk  : IN     std_ulogic;
        en   : IN     std_ulogic;
        in1  : IN     unsigned (g_bitNb - 1 DOWNTO 0);
        rst  : IN     std_ulogic;
        out1 : OUT    unsigned (g_bitNb - 1 DOWNTO 0)
    );

-- Declarations

END bufferUnsignedEnable ;






ARCHITECTURE rtl OF bufferUnsignedEnable IS
BEGIN

    buffering:process(rst, CLK)
	begin
		if rst = '1' then
			out1 <= (others=>'0') after g_tPC;
		elsif rising_edge(CLK) then
			if EN = '1' then
				out1 <= in1 after g_tPC;
			end if;
		end if;
	end process buffering;

END ARCHITECTURE rtl;




-- VHDL Entity gates.mux2to1Unsigned.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:35:12 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY mux2to1Unsigned IS
    GENERIC( 
        dataBitNb : positive := 8;
        delay     : time     := gateDelay
    );
    PORT( 
        in0    : IN     unsigned (dataBitNb-1 DOWNTO 0);
        in1    : IN     unsigned (dataBitNb-1 DOWNTO 0);
        sel    : IN     std_uLogic;
        muxOut : OUT    unsigned (dataBitNb-1 DOWNTO 0)
    );

-- Declarations

END mux2to1Unsigned ;





ARCHITECTURE sim OF mux2to1Unsigned IS

  signal selInt: std_ulogic;

BEGIN

  selInt <= to_X01(sel);

  muxSelect: process(selInt, in0, in1)
  begin
    if selInt = '0' then
      muxOut <= in0 after delay;
    elsif selInt = '1' then
      muxOut <= in1 after delay;
    elsif in0 = in1 then
      muxOut <= in0 after delay;
    else
      muxOut <= (others => 'X') after delay;
    end if;
  end process muxSelect;

END ARCHITECTURE sim;




-- VHDL Entity gates.transUnsignedUlog.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:35:04 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY transUnsignedUlog IS
    GENERIC( 
        delay     : time     := gateDelay;
        dataBitNb : positive := 8
    );
    PORT( 
        in1  : IN     unsigned (dataBitNb-1 DOWNTO 0);
        out1 : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0)
    );

-- Declarations

END transUnsignedUlog ;





ARCHITECTURE sim OF transUnsignedUlog IS
BEGIN
  out1 <= std_ulogic_vector(in1) after delay;
END ARCHITECTURE sim;




-- VHDL Entity HEIRV32.registerFile.symbol
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 11:19:02 04.11.2022
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
use work.gates.all;

ENTITY registerFile IS
    GENERIC( 
        g_dataWidth : positive := 32;
        g_btnsNb    : positive := 2;
        g_tRfRd     : time     := 100 ps;
        g_tRfWr     : time     := 60 ps;
        g_tSetup    : time     := 50 ps
    );
    PORT( 
        addr1        : IN     std_ulogic_vector (4 DOWNTO 0);
        addr2        : IN     std_ulogic_vector (4 DOWNTO 0);
        addr3        : IN     std_ulogic_vector (4 DOWNTO 0);
        btns         : IN     std_ulogic_vector (g_btnsNb-1 DOWNTO 0);
        clk          : IN     std_ulogic;
        en           : IN     std_ulogic;
        rst          : IN     std_ulogic;
        writeData    : IN     std_ulogic_vector (g_dataWidth - 1 DOWNTO 0);
        writeEnable3 : IN     std_ulogic;
        RD1          : OUT    std_ulogic_vector (g_dataWidth-1 DOWNTO 0);
        RD2          : OUT    std_ulogic_vector (g_dataWidth-1 DOWNTO 0);
        leds         : OUT    std_ulogic_vector (g_dataWidth-1 DOWNTO 0)
    );

-- Declarations

END registerFile ;





-- Handles x0 to x31 (read/write to RD1/RD2)
-- x0 is always 0
-- x30 is linked to leds
-- x31 is linked to the buttons
ARCHITECTURE rtl_synch OF registerFile IS
    -- Bank of register
    type t_registersBank is array (31 downto 0) of
        std_ulogic_vector(31 downto 0);
    -- A bank of registers
    signal larr_registers: t_registersBank;
    signal lvec_btns : std_ulogic_vector(31 downto 0);
    signal lvec_rd1, lvec_rd2 : std_ulogic_vector(31 downto 0);
BEGIN
    -- Special regs
    process(rst, clk)
    begin
        if rst = '1' then
            lvec_btns <= (others => '0');
        elsif rising_edge(clk) then
          if en = '1' then
            lvec_btns <= (btns'length to g_datawidth-1 => '0') & btns;
          end if;
        end if;
    end process;

    -- Clocked write
    process(rst, clk) begin
      if rst = '1' then
          larr_registers <= (others => (others => '0')) after g_tRfWr;
      elsif rising_edge(clk) then
          if writeEnable3 = '1' and en = '1' then
            larr_registers(to_integer(unsigned(addr3))) <= writeData after (g_tRfWr + g_tSetup);
          end if;
      end if;
    end process;

    -- Clocked read.
    -- Addr 0 wired to 0s
    process(rst, clk) begin
      if rst = '1' then
        lvec_rd1 <= (others => '0');
        lvec_rd2 <= (others => '0');
      elsif rising_edge(clk) then
        if en = '1' then
          if (to_integer(unsigned(addr1)) = 0) then
            lvec_rd1 <= (others => '0') after g_tRfRd;
          elsif (to_integer(unsigned(addr1)) = 31) then -- buttons
            lvec_rd1 <= lvec_btns after g_tRfRd;
          else
            lvec_rd1 <= larr_registers(to_integer(unsigned(addr1))) after g_tRfRd;
          end if;

          if (to_integer(unsigned(addr2)) = 0) then
            lvec_rd2 <= (others => '0') after g_tRfRd;
          elsif (to_integer(unsigned(addr2)) = 31) then -- buttons
            lvec_rd2 <= lvec_btns after g_tRfRd;
          else
            lvec_rd2 <= larr_registers(to_integer(unsigned(addr2))) after g_tRfRd;
          end if;
        end if;
      end if;
    end process;

    leds <= larr_registers(30);
    RD1 <= lvec_rd1;
    RD2 <= lvec_rd2;
END ARCHITECTURE rtl_synch;




-- VHDL Entity HEIRV32.mux4To1ULogVec.symbol
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 11:11:14 04.11.2022
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
use work.gates.all;

ENTITY mux4To1ULogVec IS
    GENERIC( 
        g_dataWidth : positive := 32;
        g_tMux      : time     := 30 ps
    );
    PORT( 
        in1  : IN     std_ulogic_vector (g_dataWidth - 1 DOWNTO 0);
        in2  : IN     std_ulogic_vector (g_dataWidth - 1 DOWNTO 0);
        in3  : IN     std_ulogic_vector (g_dataWidth-1 DOWNTO 0);
        in4  : IN     std_ulogic_vector (g_dataWidth-1 DOWNTO 0);
        sel  : IN     std_ulogic_vector (1 DOWNTO 0);
        out1 : OUT    std_ulogic_vector (g_dataWidth-1 DOWNTO 0)
    );

-- Declarations

END mux4To1ULogVec ;






ARCHITECTURE rtl OF mux4To1ULogVec IS
BEGIN

  muxSelect: process(sel, in1, in2, in3, in4)
  begin
    case to_integer(unsigned(sel)) is
      when 0 => out1 <= in1 after g_tMux;
      when 1 => out1 <= in2 after g_tMux;
      when 2 => out1 <= in3 after g_tMux;
      when 3 => out1 <= in4 after g_tMux;
      when others => out1 <= (others => 'X') after g_tMux;
    end case;
  end process muxSelect;

END ARCHITECTURE rtl;




-- VHDL Entity gates.transUlogUnsigned.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:35:05 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY transUlogUnsigned IS
    GENERIC( 
        delay     : time     := gateDelay;
        dataBitNb : positive := 8
    );
    PORT( 
        in1  : IN     std_uLogic_vector (dataBitNb-1 DOWNTO 0);
        out1 : OUT    unsigned (dataBitNb-1 DOWNTO 0)
    );

-- Declarations

END transUlogUnsigned ;





ARCHITECTURE sim OF transUlogUnsigned IS
BEGIN
  out1 <= unsigned(in1) after delay;
END ARCHITECTURE sim;




--
-- VHDL Architecture HEIRV32_MC.heirv32_mc.masterVersion
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 14:49:46 09.05.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
use work.gates.all;

-- LIBRARY HEIRV32;
-- LIBRARY HEIRV32_MC;

ARCHITECTURE masterVersion OF heirv32_mc IS

    -- Architecture declarations
    constant c_dataWidth : positive := g_dataWidth;
    constant c_bramAddrWidth : positive := 10;

    -- Internal signal declarations
    SIGNAL ALUControl  : std_ulogic_vector(2 DOWNTO 0);
    SIGNAL ALUOut      : std_ulogic_vector(c_dataWidth - 1 DOWNTO 0);
    SIGNAL ALUResult   : std_ulogic_vector(c_dataWidth-1 DOWNTO 0);
    SIGNAL ALUSrcA     : std_ulogic_vector(1 DOWNTO 0);
    SIGNAL ALUSrcB     : std_ulogic_vector(1 DOWNTO 0);
    SIGNAL PC          : unsigned(c_dataWidth - 1 DOWNTO 0);
    SIGNAL PCNext      : unsigned(c_dataWidth - 1 DOWNTO 0);
    SIGNAL PCWrite     : std_ulogic;
    SIGNAL PCu         : std_ulogic_vector(c_dataWidth - 1 DOWNTO 0);
    SIGNAL RD1         : std_ulogic_vector(c_dataWidth-1 DOWNTO 0);
    SIGNAL adr         : unsigned(c_dataWidth-1 DOWNTO 0);
    SIGNAL adrSrc      : std_uLogic;
    SIGNAL data        : std_ulogic_vector(c_dataWidth-1 DOWNTO 0);
    SIGNAL en_pcBuffer : std_ulogic;
    SIGNAL en_pcLoad   : std_ulogic;
    SIGNAL four_zeros  : std_ulogic_vector(c_dataWidth-1 DOWNTO 0);
    SIGNAL immExt      : std_ulogic_vector(c_dataWidth-1 DOWNTO 0);
    SIGNAL immSrc      : std_ulogic_vector(1 DOWNTO 0);
    SIGNAL instruction : std_ulogic_vector(c_dataWidth-1 DOWNTO 0);
    SIGNAL irWrite     : std_ulogic;
    SIGNAL memWrite    : std_ulogic;
    SIGNAL mux_four    : std_ulogic_vector(c_dataWidth-1 DOWNTO 0);
    SIGNAL mux_zeros   : std_ulogic_vector(c_dataWidth-1 DOWNTO 0);
    SIGNAL oldPC       : std_ulogic_vector(c_dataWidth - 1 DOWNTO 0);
    SIGNAL regwrite    : std_ulogic;
    SIGNAL result      : std_uLogic_vector(c_dataWidth-1 DOWNTO 0);
    SIGNAL resultSrc   : std_ulogic_vector(1 DOWNTO 0);
    SIGNAL srcA        : std_ulogic_vector(c_dataWidth-1 DOWNTO 0);
    SIGNAL srcB        : std_ulogic_vector(c_dataWidth-1 DOWNTO 0);
    SIGNAL writeData   : std_ulogic_vector(c_dataWidth-1 DOWNTO 0);
    SIGNAL zero        : std_ulogic;


    -- Component Declarations
    COMPONENT and2
    GENERIC (
        delay : time := gateDelay
    );
    PORT (
        in1  : IN     std_uLogic ;
        in2  : IN     std_uLogic ;
        out1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT mux2to1Unsigned
    GENERIC (
        dataBitNb : positive := 8;
        delay     : time     := gateDelay
    );
    PORT (
        in0    : IN     unsigned (dataBitNb-1 DOWNTO 0);
        in1    : IN     unsigned (dataBitNb-1 DOWNTO 0);
        sel    : IN     std_uLogic ;
        muxOut : OUT    unsigned (dataBitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT transUlogUnsigned
    GENERIC (
        delay     : time     := gateDelay;
        dataBitNb : positive := 8
    );
    PORT (
        in1  : IN     std_uLogic_vector (dataBitNb-1 DOWNTO 0);
        out1 : OUT    unsigned (dataBitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT transUnsignedUlog
    GENERIC (
        delay     : time     := gateDelay;
        dataBitNb : positive := 8
    );
    PORT (
        in1  : IN     unsigned (dataBitNb-1 DOWNTO 0);
        out1 : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT ALU
    GENERIC (
        g_datawidth : positive := 32;
        g_tALU      : time     := 120 ps
    );
    PORT (
        ctrl : IN     std_ulogic_vector (2 DOWNTO 0);
        srcA : IN     std_ulogic_vector (g_dataWidth-1 DOWNTO 0);
        srcB : IN     std_ulogic_vector (g_dataWidth-1 DOWNTO 0);
        res  : OUT    std_ulogic_vector (g_dataWidth-1 DOWNTO 0);
        zero : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT bufferStdULogEnable
    GENERIC (
        g_dataWidth : positive := 32
    );
    PORT (
        clk  : IN     std_ulogic ;
        en   : IN     std_uLogic ;
        in1  : IN     std_ulogic_vector (g_dataWidth-1 DOWNTO 0);
        rst  : IN     std_ulogic ;
        out1 : OUT    std_ulogic_vector (g_dataWidth - 1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT bufferUnsignedEnable
    GENERIC (
        g_bitNb : positive := 32;
        g_tPC   : time     := 40 ps
    );
    PORT (
        clk  : IN     std_ulogic ;
        en   : IN     std_ulogic ;
        in1  : IN     unsigned (g_bitNb - 1 DOWNTO 0);
        rst  : IN     std_ulogic ;
        out1 : OUT    unsigned (g_bitNb - 1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT extend
    GENERIC (
        g_dataWidth : positive := 32;
        g_tExt      : time     := 35 ps
    );
    PORT (
        input    : IN     std_ulogic_vector (31 DOWNTO 7);
        src      : IN     std_ulogic_vector (1 DOWNTO 0);
        extended : OUT    std_ulogic_vector (g_dataWidth-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT mux4To1ULogVec
    GENERIC (
        g_dataWidth : positive := 32;
        g_tMux      : time     := 30 ps
    );
    PORT (
        in1  : IN     std_ulogic_vector (g_dataWidth - 1 DOWNTO 0);
        in2  : IN     std_ulogic_vector (g_dataWidth - 1 DOWNTO 0);
        in3  : IN     std_ulogic_vector (g_dataWidth-1 DOWNTO 0);
        in4  : IN     std_ulogic_vector (g_dataWidth-1 DOWNTO 0);
        sel  : IN     std_ulogic_vector (1 DOWNTO 0);
        out1 : OUT    std_ulogic_vector (g_dataWidth-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT registerFile
    GENERIC (
        g_dataWidth : positive := 32;
        g_btnsNb    : positive := 2;
        g_tRfRd     : time     := 100 ps;
        g_tRfWr     : time     := 60 ps;
        g_tSetup    : time     := 50 ps
    );
    PORT (
        addr1        : IN     std_ulogic_vector (4 DOWNTO 0);
        addr2        : IN     std_ulogic_vector (4 DOWNTO 0);
        addr3        : IN     std_ulogic_vector (4 DOWNTO 0);
        btns         : IN     std_ulogic_vector (g_btnsNb-1 DOWNTO 0);
        clk          : IN     std_ulogic ;
        en           : IN     std_ulogic ;
        rst          : IN     std_ulogic ;
        writeData    : IN     std_ulogic_vector (g_dataWidth - 1 DOWNTO 0);
        writeEnable3 : IN     std_ulogic ;
        RD1          : OUT    std_ulogic_vector (g_dataWidth-1 DOWNTO 0);
        RD2          : OUT    std_ulogic_vector (g_dataWidth-1 DOWNTO 0);
        leds         : OUT    std_ulogic_vector (g_dataWidth-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT controlUnit
    GENERIC (
        g_datawidth : positive := 32
    );
    PORT (
        clk        : IN     std_ulogic ;
        en         : IN     std_ulogic ;
        funct3     : IN     std_ulogic_vector (2 DOWNTO 0);
        funct7     : IN     std_ulogic ;
        op         : IN     std_ulogic_vector (6 DOWNTO 0);
        rst        : IN     std_ulogic ;
        zero       : IN     std_ulogic ;
        ALUControl : OUT    std_ulogic_vector (2 DOWNTO 0);
        ALUSrcA    : OUT    std_ulogic_vector (1 DOWNTO 0);
        ALUSrcB    : OUT    std_ulogic_vector (1 DOWNTO 0);
        IRWrite    : OUT    std_ulogic ;
        PCWrite    : OUT    std_ulogic ;
        adrSrc     : OUT    std_uLogic ;
        immSrc     : OUT    std_ulogic_vector (1 DOWNTO 0);
        memWrite   : OUT    std_ulogic ;
        regwrite   : OUT    std_ulogic ;
        resultSrc  : OUT    std_ulogic_vector (1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT instructionDataManager
    GENERIC (
        g_addrWidth   : positive := 10;
        g_dataWidth   : positive := 32;
        g_programFile : string   := ""
    );
    PORT (
        adr         : IN     unsigned (g_dataWidth-1 DOWNTO 0);
        clk         : IN     std_ulogic ;
        en          : IN     std_ulogic ;
        irWrite     : IN     std_ulogic ;
        memWrite    : IN     std_ulogic ;
        reset       : IN     std_ulogic ;
        writeData   : IN     std_ulogic_vector (g_dataWidth-1 DOWNTO 0);
        data        : OUT    std_ulogic_vector (g_dataWidth-1 DOWNTO 0);
        instruction : OUT    std_ulogic_vector (g_dataWidth-1 DOWNTO 0)
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : ALU USE ENTITY HEIRV32.ALU;
--     FOR ALL : and2 USE ENTITY gates.and2;
--     FOR ALL : bufferStdULogEnable USE ENTITY HEIRV32.bufferStdULogEnable;
--     FOR ALL : bufferUnsignedEnable USE ENTITY HEIRV32.bufferUnsignedEnable;
--     FOR ALL : controlUnit USE ENTITY HEIRV32_MC.controlUnit;
--     FOR ALL : extend USE ENTITY HEIRV32.extend;
--     FOR ALL : instructionDataManager USE ENTITY HEIRV32_MC.instructionDataManager;
--     FOR ALL : mux2to1Unsigned USE ENTITY gates.mux2to1Unsigned;
--     FOR ALL : mux4To1ULogVec USE ENTITY HEIRV32.mux4To1ULogVec;
--     FOR ALL : registerFile USE ENTITY HEIRV32.registerFile;
--     FOR ALL : transUlogUnsigned USE ENTITY gates.transUlogUnsigned;
--     FOR ALL : transUnsignedUlog USE ENTITY gates.transUnsignedUlog;
    -- pragma synthesis_on


BEGIN
    -- Architecture concurrent statements
    -- HDL Embedded Text Block 1 eb1
    mux_zeros <= (c_dataWidth - 1 downto 0 => '0');
    mux_four <= std_ulogic_vector(to_unsigned(4, c_dataWidth));

    -- HDL Embedded Text Block 2 eb2
    dbg_sync: process(rst, clk)
    begin
      if rst = '1' then
        dbg_leds <= (others => '0');
      elsif rising_edge(clk) then
        dbg_leds(7 downto 0) <= 
          std_ulogic_vector(adr(9 downto 2)); -- no need to read LSBs since does +4 each time
    
        dbg_leds(15 downto 8) <= 
          std_ulogic_vector(instruction(7 downto 0));
    
        dbg_leds(23 downto 16) <= 
          std_ulogic_vector(ALUControl & "000" & resultSrc);
    
        dbg_leds(31 downto 24) <= 
          std_ulogic_vector(regwrite & immSrc & '0' & ALUSrcB & ALUSrcA);
      end if;
    end process dbg_sync;
    

    -- HDL Embedded Text Block 3 eb3
    test <= std_ulogic_vector(adr) & ALUControl & ALUSrcA & ALUSrcB & IRWrite & PCWrite & adrSrc & immSrc & memWrite & regwrite & resultSrc;
    
    


    -- Instance port mappings.
    U_and1 : and2
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => en,
            in2  => PCWrite,
            out1 => en_pcLoad
        );
    U_and2 : and2
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => en,
            in2  => irWrite,
            out1 => en_pcBuffer
        );
    U_pcMux : mux2to1Unsigned
        GENERIC MAP (
            dataBitNb => c_dataWidth,
            delay     => gateDelay
        )
        PORT MAP (
            in0    => PC,
            in1    => PCNext,
            sel    => adrSrc,
            muxOut => adr
        );
    U_resultToUnsigned : transUlogUnsigned
        GENERIC MAP (
            delay     => gateDelay,
            dataBitNb => c_dataWidth
        )
        PORT MAP (
            in1  => result,
            out1 => PCNext
        );
    U_pcToUlog : transUnsignedUlog
        GENERIC MAP (
            delay     => gateDelay,
            dataBitNb => c_dataWidth
        )
        PORT MAP (
            in1  => PC,
            out1 => PCu
        );
    U_alu : ALU
        GENERIC MAP (
            g_datawidth => c_dataWidth,
            g_tALU      => 120 ps
        )
        PORT MAP (
            ctrl => ALUControl,
            srcA => srcA,
            srcB => srcB,
            res  => ALUResult,
            zero => zero
        );
    U_aluBuffer : bufferStdULogEnable
        GENERIC MAP (
            g_dataWidth => c_dataWidth
        )
        PORT MAP (
            clk  => clk,
            en   => en,
            in1  => ALUResult,
            rst  => rst,
            out1 => ALUOut
        );
    U_pcBuffer : bufferStdULogEnable
        GENERIC MAP (
            g_dataWidth => c_dataWidth
        )
        PORT MAP (
            clk  => clk,
            en   => en_pcBuffer,
            in1  => PCu,
            rst  => rst,
            out1 => oldPC
        );
    U_pcLoadBuffer : bufferUnsignedEnable
        GENERIC MAP (
            g_bitNb => c_dataWidth,
            g_tPC   => 35 ps
        )
        PORT MAP (
            clk  => clk,
            en   => en_pcLoad,
            in1  => PCNext,
            rst  => rst,
            out1 => PC
        );
    U_extend : extend
        GENERIC MAP (
            g_dataWidth => c_dataWidth,
            g_tExt      => 35 ps
        )
        PORT MAP (
            input    => instruction(31 DOWNTO 7),
            src      => immSrc,
            extended => immExt
        );
    U_resultSel : mux4To1ULogVec
        GENERIC MAP (
            g_dataWidth => c_dataWidth,
            g_tMux      => 30 ps
        )
        PORT MAP (
            in1  => ALUOut,
            in2  => data,
            in3  => ALUResult,
            in4  => four_zeros,
            sel  => resultSrc,
            out1 => result
        );
    U_srcASel : mux4To1ULogVec
        GENERIC MAP (
            g_dataWidth => c_dataWidth,
            g_tMux      => 30 ps
        )
        PORT MAP (
            in1  => PCu,
            in2  => oldPC,
            in3  => RD1,
            in4  => mux_zeros,
            sel  => ALUSrcA,
            out1 => srcA
        );
    U_srcBSel : mux4To1ULogVec
        GENERIC MAP (
            g_dataWidth => c_dataWidth,
            g_tMux      => 30 ps
        )
        PORT MAP (
            in1  => writeData,
            in2  => immExt,
            in3  => mux_four,
            in4  => mux_zeros,
            sel  => ALUSrcB,
            out1 => srcB
        );
    U_registerFile : registerFile
        GENERIC MAP (
            g_dataWidth => c_dataWidth,
            g_btnsNb    => g_btnsNb,
            g_tRfRd     => 100 ps,
            g_tRfWr     => 60 ps,
            g_tSetup    => 50 ps
        )
        PORT MAP (
            addr1        => instruction(19 DOWNTO 15),
            addr2        => instruction(24 DOWNTO 20),
            addr3        => instruction(11 DOWNTO 7),
            btns         => btns,
            clk          => clk,
            en           => en,
            rst          => rst,
            writeData    => result,
            writeEnable3 => regwrite,
            RD1          => RD1,
            RD2          => writeData,
            leds         => leds
        );
    U_controlUnit : controlUnit
        GENERIC MAP (
            g_datawidth => c_dataWidth
        )
        PORT MAP (
            clk        => clk,
            en         => en,
            funct3     => instruction(14 DOWNTO 12),
            funct7     => instruction(30),
            op         => instruction(6 DOWNTO 0),
            rst        => rst,
            zero       => zero,
            ALUControl => ALUControl,
            ALUSrcA    => ALUSrcA,
            ALUSrcB    => ALUSrcB,
            IRWrite    => irWrite,
            PCWrite    => PCWrite,
            adrSrc     => adrSrc,
            immSrc     => immSrc,
            memWrite   => memWrite,
            regwrite   => regwrite,
            resultSrc  => resultSrc
        );
    U_instrDataManager : instructionDataManager
        GENERIC MAP (
            g_addrWidth   => c_bramAddrWidth,
            g_dataWidth   => c_dataWidth,
            g_programFile => g_programFile
        )
        PORT MAP (
            adr         => adr,
            clk         => clk,
            en          => en,
            irWrite     => irWrite,
            memWrite    => memWrite,
            reset       => rst,
            writeData   => writeData,
            data        => data,
            instruction => instruction
        );

END masterVersion;




-- VHDL Entity gates.logic1.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:35:13 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY logic1 IS
    PORT( 
        logic_1 : OUT    std_uLogic
    );

-- Declarations

END logic1 ;





ARCHITECTURE sim OF logic1 IS
BEGIN
  logic_1 <= '1';
END sim;




-- VHDL netlist generated by SCUBA Diamond (64-bit) 3.12.1.454
-- Module  Version: 5.7
--C:\lscc\diamond\3.12\ispfpga\bin\nt64\scuba.exe -w -n lattice_pll -lang vhdl -synth synplify -bus_exp 7 -bb -arch sa5p00 -type pll -fin 100.00 -fclkop 50 -fclkop_tol 0.0 -fclkos 10 -fclkos_tol 0.0 -phases 0 -phase_cntl STATIC -fb_mode 1 -fdc C:/temp/eda/axel.amand/car-labs/Board/diamond/clarity/lattice_pll/lattice_pll.fdc 

-- Mon Feb 20 18:06:31 2023

library IEEE;
use IEEE.std_logic_1164.all;
library ECP5U;
use ECP5U.components.all;

ENTITY lattice_pll IS
    PORT( 
        clkIn  : IN     std_ulogic;
        clk50M : OUT    std_ulogic;
        clk10M : OUT    std_ulogic
    );

-- Declarations

END lattice_pll ;

architecture Structure of lattice_pll is

    -- internal signal declarations
    signal REFCLK: std_logic;
    signal LOCK: std_logic;
    signal CLKOS_t: std_logic;
    signal CLKOP_t: std_logic;
    signal scuba_vhi: std_logic;
    signal scuba_vlo: std_logic;

    attribute FREQUENCY_PIN_CLKOS : string; 
    attribute FREQUENCY_PIN_CLKOP : string; 
    attribute FREQUENCY_PIN_CLKI : string; 
    attribute ICP_CURRENT : string; 
    attribute LPF_RESISTOR : string; 
    attribute FREQUENCY_PIN_CLKOS of PLLInst_0 : label is "10.000000";
    attribute FREQUENCY_PIN_CLKOP of PLLInst_0 : label is "50.000000";
    attribute FREQUENCY_PIN_CLKI of PLLInst_0 : label is "100.000000";
    attribute ICP_CURRENT of PLLInst_0 : label is "12";
    attribute LPF_RESISTOR of PLLInst_0 : label is "8";
    attribute syn_keep : boolean;
    attribute NGD_DRC_MASK : integer;
    attribute NGD_DRC_MASK of Structure : architecture is 1;

begin
    -- component instantiation statements
    scuba_vhi_inst: VHI
        port map (Z=>scuba_vhi);

    scuba_vlo_inst: VLO
        port map (Z=>scuba_vlo);

    PLLInst_0: EHXPLLL
        generic map (PLLRST_ENA=> "DISABLED", INTFB_WAKE=> "DISABLED", 
        STDBY_ENABLE=> "DISABLED", DPHASE_SOURCE=> "DISABLED", 
        CLKOS3_FPHASE=>  0, CLKOS3_CPHASE=>  0, CLKOS2_FPHASE=>  0, 
        CLKOS2_CPHASE=>  0, CLKOS_FPHASE=>  0, CLKOS_CPHASE=>  59, 
        CLKOP_FPHASE=>  0, CLKOP_CPHASE=>  11, PLL_LOCK_MODE=>  0, 
        CLKOS_TRIM_DELAY=>  0, CLKOS_TRIM_POL=> "FALLING", 
        CLKOP_TRIM_DELAY=>  0, CLKOP_TRIM_POL=> "FALLING", 
        OUTDIVIDER_MUXD=> "DIVD", CLKOS3_ENABLE=> "DISABLED", 
        OUTDIVIDER_MUXC=> "DIVC", CLKOS2_ENABLE=> "DISABLED", 
        OUTDIVIDER_MUXB=> "DIVB", CLKOS_ENABLE=> "ENABLED", 
        OUTDIVIDER_MUXA=> "DIVA", CLKOP_ENABLE=> "ENABLED", CLKOS3_DIV=>  1, 
        CLKOS2_DIV=>  1, CLKOS_DIV=>  60, CLKOP_DIV=>  12, CLKFB_DIV=>  1, 
        CLKI_DIV=>  2, FEEDBK_PATH=> "CLKOP")
        port map (CLKI=>clkIn, CLKFB=>CLKOP_t, PHASESEL1=>scuba_vlo, 
            PHASESEL0=>scuba_vlo, PHASEDIR=>scuba_vlo, 
            PHASESTEP=>scuba_vlo, PHASELOADREG=>scuba_vlo, 
            STDBY=>scuba_vlo, PLLWAKESYNC=>scuba_vlo, RST=>scuba_vlo, 
            ENCLKOP=>scuba_vlo, ENCLKOS=>scuba_vlo, ENCLKOS2=>scuba_vlo, 
            ENCLKOS3=>scuba_vlo, CLKOP=>CLKOP_t, CLKOS=>CLKOS_t, 
            CLKOS2=>open, CLKOS3=>open, LOCK=>LOCK, INTLOCK=>open, 
            REFCLK=>REFCLK, CLKINTFB=>open);

    clk10M <= CLKOS_t;
    clk50M <= CLKOP_t;
end architecture Structure;




-- VHDL Entity sequential.DFF.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:46:19 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY DFF IS
    GENERIC( 
        delay : time := gateDelay
    );
    PORT( 
        CLK : IN     std_uLogic;
        CLR : IN     std_uLogic;
        D   : IN     std_uLogic;
        Q   : OUT    std_uLogic
    );

-- Declarations

END DFF ;





ARCHITECTURE sim OF DFF IS
BEGIN

  process(clk, clr)
  begin
    if clr = '1' then
      q <= '0' after delay;
    elsif rising_edge(clk) then
      q <= d after delay;
    end if;
  end process;

END sim;




--
-- VHDL Architecture Board.ebs3_mc.struct
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 14:51:06 09.05.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

-- LIBRARY gates;
use work.gates.all;

-- LIBRARY common;
-- LIBRARY HEIRV32;
-- LIBRARY HEIRV32_MC;
-- LIBRARY sequential;

ARCHITECTURE struct OF ebs3_mc IS

    -- Architecture declarations

    -- Internal signal declarations
    SIGNAL D            : std_uLogic;
    SIGNAL T            : std_uLogic;
    SIGNAL bts          : std_ulogic_vector(c_btnsNb-1 DOWNTO 0);
    SIGNAL clk_red      : std_uLogic;
    SIGNAL en_full_dbn  : std_ulogic;
    SIGNAL en_step_dbn  : std_ulogic;
    SIGNAL falling1     : std_ulogic;
    SIGNAL full         : std_uLogic;
    SIGNAL lds          : std_ulogic_vector(c_dataWidth-1 DOWNTO 0);
    SIGNAL resetSynch_n : std_uLogic;
    SIGNAL rst          : std_uLogic;
    SIGNAL rst_synch    : std_uLogic;
    SIGNAL step         : std_ulogic;

    -- Implicit buffer signal declarations
    SIGNAL sys_en_internal : std_ulogic;


    -- Component Declarations
    COMPONENT debouncer
    GENERIC (
        counterBitNb : positive   := 18;
        invertInput  : std_ulogic := '0'
    );
    PORT (
        clock     : IN     std_ulogic ;
        input     : IN     std_ulogic ;
        reset     : IN     std_ulogic ;
        debounced : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT edgeDetector
    PORT (
        clock   : IN     std_ulogic ;
        pulse   : IN     std_ulogic ;
        reset   : IN     std_ulogic ;
        falling : OUT    std_ulogic ;
        rising  : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT bufferUlogic
    GENERIC (
        delay : time := gateDelay
    );
    PORT (
        in1  : IN     std_uLogic ;
        out1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT inverter
    GENERIC (
        delay : time := gateDelay
    );
    PORT (
        in1  : IN     std_uLogic ;
        out1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT logic1
    PORT (
        logic_1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT or2
    GENERIC (
        delay : time := gateDelay
    );
    PORT (
        in1  : IN     std_uLogic ;
        in2  : IN     std_uLogic ;
        out1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT lattice_pll
    PORT (
        clkIn  : IN     std_ulogic ;
        clk50M : OUT    std_ulogic ;
        clk10M : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT heirv32_mc
    GENERIC (
        g_programFile : string   := "C:/dev/car-heirv/Simulation/code.txt";
        g_btnsNb      : positive := 2;
        g_dataWidth   : positive := 32
    );
    PORT (
        btns     : IN     std_ulogic_vector (g_btnsNb-1 DOWNTO 0);
        clk      : IN     std_ulogic ;
        en       : IN     std_ulogic ;
        rst      : IN     std_ulogic ;
        dbg_leds : OUT    std_ulogic_vector (31 DOWNTO 0);
        leds     : OUT    std_ulogic_vector (g_dataWidth-1 DOWNTO 0);
        test     : OUT    std_ulogic_vector (32+3+2+2+1+1+1+2+1+1+2 - 1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT DFF
    GENERIC (
        delay : time := gateDelay
    );
    PORT (
        CLK : IN     std_uLogic ;
        CLR : IN     std_uLogic ;
        D   : IN     std_uLogic ;
        Q   : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT TFF
    GENERIC (
        delay : time := gateDelay
    );
    PORT (
        CLK : IN     std_uLogic ;
        CLR : IN     std_uLogic ;
        T   : IN     std_uLogic ;
        Q   : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT freqDivider
    GENERIC (
        divideValue : positive := 256;
        delay       : time     := gateDelay
    );
    PORT (
        clock  : IN     std_ulogic ;
        reset  : IN     std_ulogic ;
        enable : OUT    std_ulogic 
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : DFF USE ENTITY sequential.DFF;
--     FOR ALL : TFF USE ENTITY sequential.TFF;
--     FOR ALL : bufferUlogic USE ENTITY gates.bufferUlogic;
--     FOR ALL : debouncer USE ENTITY common.debouncer;
--     FOR ALL : edgeDetector USE ENTITY common.edgeDetector;
--     FOR ALL : freqDivider USE ENTITY sequential.freqDivider;
--     FOR ALL : heirv32_mc USE ENTITY HEIRV32_MC.heirv32_mc;
--     FOR ALL : inverter USE ENTITY gates.inverter;
--     FOR ALL : lattice_pll USE ENTITY HEIRV32.lattice_pll;
--     FOR ALL : logic1 USE ENTITY gates.logic1;
--     FOR ALL : or2 USE ENTITY gates.or2;
    -- pragma synthesis_on


BEGIN
    -- Architecture concurrent statements
    -- HDL Embedded Text Block 2 E_IO
    leds <= not lds;
    process(rst, clk_red)
    begin
      if rst='1' then
        bts <= (others => '0');
      elsif rising_edge(clk_red) then
        bts <= not btns;
      end if;
    end process;


    -- Instance port mappings.
    U_fullDbnc : debouncer
        GENERIC MAP (
            counterBitNb => 21,
            invertInput  => '0'
        )
        PORT MAP (
            clock     => clk_red,
            input     => en_full_n,
            reset     => rst_synch,
            debounced => en_full_dbn
        );
    U_stepDbnc : debouncer
        GENERIC MAP (
            counterBitNb => 21,
            invertInput  => '0'
        )
        PORT MAP (
            clock     => clk_red,
            input     => en_step_n,
            reset     => rst_synch,
            debounced => en_step_dbn
        );
    U_fullEdgeDetect : edgeDetector
        PORT MAP (
            clock   => clk_red,
            pulse   => en_full_dbn,
            reset   => rst_synch,
            falling => falling1,
            rising  => OPEN
        );
    U_stepEdgeDetect : edgeDetector
        PORT MAP (
            clock   => clk_red,
            pulse   => en_step_dbn,
            reset   => rst_synch,
            falling => step,
            rising  => OPEN
        );
    U_clkBuffer : bufferUlogic
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => clk_red,
            out1 => LED_G
        );
    U_enInverter : inverter
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => sys_en_internal,
            out1 => LED_R
        );
    U_rstDFFInverter : inverter
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => resetSynch_n,
            out1 => rst_synch
        );
    U_rstInverter : inverter
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => rst_n,
            out1 => rst
        );
    U_logic1 : logic1
        PORT MAP (
            logic_1 => D
        );
    U_enOr : or2
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => step,
            in2  => full,
            out1 => sys_en_internal
        );
    U_pll : lattice_pll
        PORT MAP (
            clkIn  => clk,
            clk50M => clk_red,
            clk10M => OPEN
        );
    U_heirv32 : heirv32_mc
        GENERIC MAP (
            g_programFile => c_programFile,
            g_btnsNb      => c_btnsNb,
            g_dataWidth   => c_dataWidth
        )
        PORT MAP (
            btns     => bts,
            clk      => clk_red,
            en       => sys_en_internal,
            rst      => rst_synch,
            dbg_leds => dbg_leds,
            leds     => lds,
            test     => OPEN
        );
    U_rstDFF : DFF
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            CLK => clk,
            CLR => rst,
            D   => D,
            Q   => resetSynch_n
        );
    U_blinkerDFF : TFF
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            CLK => clk_red,
            CLR => rst_synch,
            T   => T,
            Q   => heartbeat
        );
    U_fullT : TFF
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            CLK => clk_red,
            CLR => rst_synch,
            T   => falling1,
            Q   => full
        );
    U_blinker : freqDivider
        GENERIC MAP (
            divideValue => c_clockFrequencyHz,
            delay       => gateDelay
        )
        PORT MAP (
            clock  => clk_red,
            reset  => rst_synch,
            enable => T
        );

    -- Implicit buffered output assignments
    sys_en <= sys_en_internal;

END struct;




